<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>代码重构 - 后端部分代码 - TechNotes</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=google-site-verification content="bNoGNFra3MiXXaWKFvM99FCJ_8i2PcE8SQx_IF5kmgk"><meta name=baidu-site-verification content="code-ctRbhYH9jN"><meta name=author content="TechNotes"><meta name=description content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。 在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将"><meta name=keywords content="Java,Spring,Spring boot,Spring cloud,Golang,微服务,Microservices,Ruby on Rails,DevOps,Agile,容器化,Docker,K8S,项目管理,软件架构,产品研发"><meta name=generator content="Hugo 0.76.5 with theme even"><link rel=canonical href=https://technotes.guru/post/2019/refactor-the-backend/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.1677af8bfef483dc4ce35f26d419b9255e02c00fa5dc6b760fcabed19b39a963.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.css><meta property="og:title" content="代码重构 - 后端部分代码"><meta property="og:description" content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。 在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将"><meta property="og:type" content="article"><meta property="og:url" content="https://technotes.guru/post/2019/refactor-the-backend/"><meta property="article:published_time" content="2019-02-28T00:00:00+00:00"><meta property="article:modified_time" content="2019-02-28T00:00:00+00:00"><meta itemprop=name content="代码重构 - 后端部分代码"><meta itemprop=description content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。 在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将"><meta itemprop=datePublished content="2019-02-28T00:00:00+00:00"><meta itemprop=dateModified content="2019-02-28T00:00:00+00:00"><meta itemprop=wordCount content="1614"><meta itemprop=keywords content="重构,设计模式,"><meta name=twitter:card content="summary"><meta name=twitter:title content="代码重构 - 后端部分代码"><meta name=twitter:description content="前一篇 主要写了一下前端部分的重构，这一篇则主要关注后端部分。 在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示： 在后端部分，我先将"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>TechNotes</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>TechNotes</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>代码重构 - 后端部分代码</h1><div class=post-meta><span class=post-time>2019-02-28</span><div class=post-category><a href=/categories/%E9%87%8D%E6%9E%84/>重构</a>
<a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#代码实现>代码实现</a><ul><li><a href=#原来的实现>原来的实现</a></li><li><a href=#重构过程>重构过程</a></li><li><a href=#重构后的代码>重构后的代码</a></li></ul></li><li><a href=#后记>后记</a></li></ul></li></ul></nav></div></div><div class=post-content><p><a href=https://technotes.guru/post/2019/refactor-the-frontend/>前一篇
</a>主要写了一下前端部分的重构，这一篇则主要关注后端部分。</p><p>在前一篇后面说到了一个很实用的套路（模式），其类图如下图所示：
<img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203814.png alt></p><p>在后端部分，我先将后端Java代码的类图画出来：
<img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203838.png alt></p><p>可以发现，还是一样的套路。</p><h2 id=代码实现>代码实现</h2><p>下面则具体说下实现，首先是说一下原来的系统的实现，然后是重构的实现。</p><h3 id=原来的实现>原来的实现</h3><p>在上一篇前端部分，拿了两个方法作为示例，在方法体的后面，则都是通过<code>POST</code>请求调用后端的Controller。</p><pre><code>postVue(&quot;${ctx}/BusinessOpportunity/openAcct&quot;,params,function (data) {......
postVue(&quot;${ctx}/BusinessOpportunity/openAmlInviteAcct&quot;,params,function (data) {......

</code></pre><p>这里是原有的<code>Controller</code>的实现：
<img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203911.png alt></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016203937.png alt></p><p>然后则是<code>Service</code>的实现：</p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204019.png alt></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204039.png alt></p><p>然后就是<code>Service</code>调用不同的<code>MyBatis</code>的<code>dao</code>层实现。</p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204102.png alt></p><p>从实现上来说，就是一一相对应，优点是代码过程清晰明了，基本上完全反映实现的意图。缺点自然也很明显，比如大量重复的代码，并且也没有代码复用等。</p><h3 id=重构过程>重构过程</h3><p>这部分这样描述下重构的部分。上一篇中提到了我对于重构的两个原则：</p><ol><li>尽可能的代码复用</li><li>为使用方提供一致的调用外观</li></ol><p>所以这一部分，还是会基于这两个主要原则，并且主要针对Controller层和Service层。</p><p>由于是前后端分离，所以这部分是Restful风格的，WEB API作为前后端的契约，一是URL尽量的符合REST语义，二是传输的数据(payload)。</p><p>这个是REST Controller的实现：</p><pre><code>@PostMapping(&quot;/api/opportunities/batch&quot;)
public ResponseEntity&lt;?&gt; batchProcess(@RequestBody OpportunityBatchRequest request) {
	log.info(&quot;Process opportunity batch action - type: {}&quot;, request.getType());
	List&lt;String&gt; emailSendFailedList;
	try {
		businessOpportunityProcessorService.process(request);
		emailSendFailedList = businessOpportunityProcessorService.getAllEmailSendFailed();
	} catch (Exception e) {
		log.error(&quot;Process opportunity batch action failed, type: {}, root cause: {}&quot;, request.getType(), e);
		return WebUtil.error(e.getMessage());
	}

	String message = &quot;保存成功,以下企业发送通知失败，请检查：&quot; + String.join(&quot;, &quot;, emailSendFailedList);

	return new ResponseEntity&lt;&gt;(RestResponse.builder().status(HttpStatus.OK.value()).body(Boolean.TRUE).message(message).build(), HttpStatus.OK);
}
</code></pre><p><code>/api/opportunities</code> 这部分其实是放<code>RestController</code>类注解上的，这里只是为了说明。
另外，按照REST语义，针对不同的资源的操作，是区分GET、POST、DELETE等动词的，但是在真实的项目环境下，其实很难严格按照REST语义的，所以这里针对批处理的方式，统一使用了POST。</p><p>这个是<code>RequestBody</code>的部分，作为数据(schema)，<code>type</code>表述执行什么操作，<code>data</code>则是本次操作的数据部分。</p><pre><code>@Data
@ToString
public class OpportunityBatchRequest {
    private String type;
    private List&lt;RequestData&gt; data;

    @Data
    public static class RequestData {
        private String companyName;
        private String contactNumber;
        private Integer customerId;
        private String email;
        private String opportunityId;
    }
}
</code></pre><p>这部分就是针对批处理操作的Controller层，下面则是Service层，由于在上面已经给出了UML类图，所以这里主要是给出一些具体的实现：</p><p>首先是定义接口，用以规范行为，这边的泛型其实并没有实际的意义，直接就是<code>OpportunityBatchRequest </code>这个类</p><pre><code>public interface OpportunityProcessor&lt;T&gt; {
    boolean supports(String type);
    void process(T request) throws ProcessException;
}
</code></pre><p>主要是两个方法：</p><ul><li>supports：用以在具体的实现类中表达支持哪种<code>type</code>的处理</li><li>process： 业务处理方法</li></ul><p>具体的子类的实现示例如下：</p><pre><code>/**
 * 开通反洗钱
 */
@Service
@Slf4j
public class OpenAmlAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlAccount&quot;;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlAccount action&quot;);

    }
}
</code></pre><pre><code>/**
 * 开通反洗钱邀请
 */
@Service
@Slf4j
public class OpenAmlInviteAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlInviteAccount&quot;;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlInviteAccount action&quot;);

    }
}
</code></pre><p>这里的抽象父类<code>AbstractOpportunityProcessor</code>，用以处理一些较为公共的逻辑等，比如注入公共组件，抽些公共的方法等。引入这个抽象类的性价比是很高的。</p><h3 id=重构后的代码>重构后的代码</h3><p>这个例子中，有几个操作都是开通账号、邀请相关的，所以，涉及开通账号方法，就可以放在这个抽象父类中，而相应的子类，则只需要说明账户类型，就可以了：</p><pre><code>/**
 * 开通反洗钱
 */
@Service
@Slf4j
public class OpenAmlAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlAccount&quot;;
    private static final String ACCOUNT_OPEN_MODE = Constants.AcctOpenMode.AML;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlAccount action&quot;);

        for (OpportunityBatchRequest.RequestData requestData : request.getData()) {
            openAccount(requestData, ACCOUNT_OPEN_MODE);
        }
    }
}

/**
 * 开通反洗钱邀请
 */
@Service
@Slf4j
public class OpenAmlInviteAccountProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;OpenAmlInviteAccount&quot;;
    private static final String ACCOUNT_OPEN_MODE = Constants.AcctOpenMode.INVITE_AML;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process OpenAmlInviteAccount action&quot;);

        for (OpportunityBatchRequest.RequestData requestData : request.getData()) {
            openAccount(requestData, ACCOUNT_OPEN_MODE);
        }
    }
}
</code></pre><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/20201016204126.png alt></p><p>而对于其他的操作，则只需要在具体自己的子类中实现，如删除:</p><pre><code>/**
 * 批量删除
 */
@Service
@Slf4j
public class DeleteOpportunitiesProcessor extends AbstractOpportunityProcessor&lt;OpportunityBatchRequest&gt; {
    private static final String SUPPORTS_TYPE = &quot;DeleteOpportunities&quot;;

    @Override
    public boolean supports(String type) {
        return SUPPORTS_TYPE.equalsIgnoreCase(type);
    }

    @Override
    public void process(OpportunityBatchRequest request) throws ProcessException {
        log.info(&quot;Process DeleteOpportunities action&quot;);

        List&lt;String&gt; opportunityIdList = request.getData()
                .stream()
                .map(OpportunityBatchRequest.RequestData::getOpportunityId)
                .collect(Collectors.toList());
        businessOpportunityMapper.deleteOpportunitiesInBatch(opportunityIdList);
    }
}
</code></pre><h2 id=后记>后记</h2><p>这是本次重构的后端部分，相应的套路（模式）也更多一些，自己也相对的更加熟悉一些。这两篇博客提到的模式，在很多场景下都可以使用。</p><p>谢谢阅读。</p><p><strong>Works，then better.</strong></p><p><em>(2019-02-28 发表于简书)</em></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>TechNotes</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2019-02-28</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E9%87%8D%E6%9E%84/>重构</a>
<a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><nav class=post-nav><a class=prev href=/post/2019/bert-as-servcie%E5%9C%A8%E5%8D%95gpu%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%B3%BB%E7%BB%9F%E5%81%9C%E9%A1%BF%E7%9A%84%E9%97%AE%E9%A2%98/><i class="iconfont icon-left"></i><span class="prev-text nav-default">解决Bert as servcie在单GPU，单线程测试场景下无响应的问题</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/2019/refactor-the-frontend/><span class="next-text nav-default">代码重构 - 前端部分代码</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=cloudhuang/cloudhuang.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://technotes.guru/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>TechNotes</span></span></div><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?077988cdd83c4fada527c368cf2c84a9";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script></body></html>