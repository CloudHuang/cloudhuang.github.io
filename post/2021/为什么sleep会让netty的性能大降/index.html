<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>为什么sleep会让Netty的性能大降 - TechNotes</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=google-site-verification content="bNoGNFra3MiXXaWKFvM99FCJ_8i2PcE8SQx_IF5kmgk"><meta name=baidu-site-verification content="code-ctRbhYH9jN"><meta name=author content="TechNotes"><meta name=description content="TL;DR 即时通讯技术分享 在知乎上分享了一些列的高性能网络编程的文章，该系列文章从底层原理说起，提到了高性能网络的方方面面，特别的干货。但是在第七篇"><meta name=keywords content="Java,Spring,Spring boot,Spring cloud,Golang,微服务,Microservices,Ruby on Rails,DevOps,Agile,容器化,Docker,K8S,项目管理,软件架构,产品研发"><meta name=generator content="Hugo 0.76.5 with theme even"><link rel=canonical href=https://technotes.guru/post/2021/%E4%B8%BA%E4%BB%80%E4%B9%88sleep%E4%BC%9A%E8%AE%A9netty%E7%9A%84%E6%80%A7%E8%83%BD%E5%A4%A7%E9%99%8D/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.1677af8bfef483dc4ce35f26d419b9255e02c00fa5dc6b760fcabed19b39a963.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.css><meta property="og:title" content="为什么sleep会让Netty的性能大降"><meta property="og:description" content="TL;DR 即时通讯技术分享 在知乎上分享了一些列的高性能网络编程的文章，该系列文章从底层原理说起，提到了高性能网络的方方面面，特别的干货。但是在第七篇"><meta property="og:type" content="article"><meta property="og:url" content="https://technotes.guru/post/2021/%E4%B8%BA%E4%BB%80%E4%B9%88sleep%E4%BC%9A%E8%AE%A9netty%E7%9A%84%E6%80%A7%E8%83%BD%E5%A4%A7%E9%99%8D/"><meta property="article:published_time" content="2021-03-17T13:37:54+08:00"><meta property="article:modified_time" content="2021-03-17T13:37:54+08:00"><meta itemprop=name content="为什么sleep会让Netty的性能大降"><meta itemprop=description content="TL;DR 即时通讯技术分享 在知乎上分享了一些列的高性能网络编程的文章，该系列文章从底层原理说起，提到了高性能网络的方方面面，特别的干货。但是在第七篇"><meta itemprop=datePublished content="2021-03-17T13:37:54+08:00"><meta itemprop=dateModified content="2021-03-17T13:37:54+08:00"><meta itemprop=wordCount content="1972"><meta itemprop=keywords content="Netty,"><meta name=twitter:card content="summary"><meta name=twitter:title content="为什么sleep会让Netty的性能大降"><meta name=twitter:description content="TL;DR 即时通讯技术分享 在知乎上分享了一些列的高性能网络编程的文章，该系列文章从底层原理说起，提到了高性能网络的方方面面，特别的干货。但是在第七篇"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>TechNotes</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>TechNotes</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>为什么sleep会让Netty的性能大降</h1><div class=post-meta><span class=post-time>2021-03-17</span><div class=post-category><a href=/categories/netty/>Netty</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#tldr>TL;DR</a></li><li><a href=#netty-线程模型>Netty 线程模型</a><ul><li><a href=#netty-请求流程>Netty 请求流程</a></li></ul></li><li><a href=#jdk-nio-线程模型>JDK NIO 线程模型</a></li><li><a href=#总结>总结</a></li><li><a href=#结论>结论</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=tldr>TL;DR</h2><p><a href=https://www.zhihu.com/column/helloim target=_blank>即时通讯技术分享</a> 在知乎上分享了一些列的高性能网络编程的文章，该系列文章从底层原理说起，提到了高性能网络的方方面面，特别的干货。但是在第七篇文章中，
<a href="https://zhuanlan.zhihu.com/p/214330310#comment-1274226668?notificationId=1351107234450092032" target=_blank>高性能网络编程(七)：到底什么是高并发？一文即懂！
</a>，作者通过ab分别对Java(Netty)和PHP(Swoole)进行性能压测的部分让我产生了一些疑惑。</p><p>作者使用了<code>ab</code>命令分别进行了压测</p><p>ab命令：<code>docker run --rm jordi/ab -k -c 1000 -n 1000000 http://10.234.3.32:5555/</code></p><p>在并发1000进行100万次Http请求的基准测试中的结果如下。</p><p><strong>Netty的压测结果:</strong></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/v2-254ce06a11e42c9ba1c50418a81c7e00_720w.jpg alt=img></p><p><strong>Swoole的压测结果:</strong></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/v2-445f9e0ccedd446dd774a6ce14de8d53_720w.jpg alt=img></p><p>附图直接使用了上述文章中的图片，从数据来看Netty的Requests per second为84042.11，Swoole的Requests per second的结果为87222.98，可见在默认情况下，两者的表现基本是一致的。(不过docker容器、1G内存+2核CPU，能跑出这样的QPS，还是挺意外的)</p><p>但是后来作者通过在Java和PHP代码中,分别加上 sleep(0.01) //秒 的代码，模拟0.01秒的系统调用阻塞，下面就产生了奇迹时刻：</p><p><strong>Netty的压测结果:</strong></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/v2-5d23f2013dce03b30ae8ed4cd0cfcd07_720w.jpg alt=img></p><p><strong>Swoole的压测结果:</strong></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/v2-20236790e5626397b6f7f07f87853616_720w.jpg alt=img></p><p>可以看到，Netty的QPS一下子降低到了1562.69，较原来的8万多，一下子降低了好几十倍。比起Swoole，也差了好几倍，作者也提到 “**从结果中可以看出：**基于协程的php+ swoole服务比 Java + netty服务的QPS高了6倍。” 。而且这还是0.01秒的结果，到了真实的业务系统上，实际的业务操作时间往往都超过0.01秒。</p><p>那么，是什么原因，让Netty的性能大降呢？</p><h2 id=netty-线程模型>Netty 线程模型</h2><p>首先需要了解下Netty的线程模型，那上文中的示例来说，其实际上是官方的Http中的HelloWorld示例 -
<a href=https://github.com/netty/netty/blob/4.1/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java target=_blank>HttpHelloWorldServer.java</a></p><pre><code class=language-java>public final class HttpHelloWorldServer {

    static final boolean SSL = System.getProperty(&quot;ssl&quot;) != null;
    static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, SSL? &quot;8443&quot; : &quot;8080&quot;));

    public static void main(String[] args) throws Exception {
        // Configure SSL.
        final SslContext sslCtx;
        if (SSL) {
            SelfSignedCertificate ssc = new SelfSignedCertificate();
            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
        } else {
            sslCtx = null;
        }

        // Configure the server.
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.option(ChannelOption.SO_BACKLOG, 1024);
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class)
             .handler(new LoggingHandler(LogLevel.INFO))
             .childHandler(new HttpHelloWorldServerInitializer(sslCtx));

            Channel ch = b.bind(PORT).sync().channel();

            System.err.println(&quot;Open your web browser and navigate to &quot; +
                    (SSL? &quot;https&quot; : &quot;http&quot;) + &quot;://127.0.0.1:&quot; + PORT + '/');

            ch.closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
</code></pre><p>这是一个比较典型的服务端示例程序，在启动类 <code>main</code> 方法中负责创建Netty服务端，分别实例化了 2 个 <code>EventLoopGroup</code>，<code>bossGroup </code>和<code>workerGroup</code>。一个<code> EventLoopGroup</code> 实际就是一个 <code>EventLoop</code> 线程组，负责管理 <code>EventLoop</code> 的申请和释放。</p><p><code>EventLoopGroup</code> 管理的线程数可以通过构造函数设置，如果没有设置，默认取<code>io.netty.eventLoopThreads</code>系统变量的值，如果该系统变量也没有指定，则设置为可用的 CPU 内核数 × 2 (<code>NettyRuntime.availableProcessors() * 2</code>)。</p><p><code>bossGroup</code> 线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，如果系统只有一个服务端端口需要监听，则建议 <code>bossGroup</code> 线程组线程数设置为 1。</p><p><code>workerGroup</code> 没有指定线程数，由于我的机器是6核12线程，所以最后 <code>workerGroup</code> 的线程数为24。</p><pre><code class=language-java>io.netty.channel.MultithreadEventLoopGroup#MultithreadEventLoopGroup(int, java.util.concurrent.Executor, java.lang.Object...)

private static final int DEFAULT_EVENT_LOOP_THREADS;

static {
    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
        &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));

    if (logger.isDebugEnabled()) {
        logger.debug(&quot;-Dio.netty.eventLoopThreads: {}&quot;, DEFAULT_EVENT_LOOP_THREADS);
    }
}
......
/**
     * @see MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, Executor, Object...)
     */
protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}
</code></pre><h3 id=netty-请求流程>Netty 请求流程</h3><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/image-20210317174214132.png alt=image-20210317174214132></p><p>大概的流程就是:</p><ol><li>bossGroup接受来自客户端的请求</li><li>通过轮询的方式绑定一个worker线程</li><li>worker线程通过**Selectors（选择器）**的方式处理通道事件 (JDK NIO)</li></ol><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/image-20210317174614198.png alt=image-20210317174614198></p><p>当Netty 的 NioEventLoop 读取到消息之后，一直都是由NioEventLoop 调用用户的 ChannelHandler，期间不进行线程切换。既所有I/O操作和事件处理都在EventLoop所在的线程上执行，这种串行化的方式避免了多线程情况下的上下文切换及锁的竞争，从性能角度来看是最优的。</p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/image-20210317180646854.png alt=image-20210317180646854></p><p><img src=https://raw.githubusercontent.com/cloudhuang/cloudhuang.github.io/pictures/pictures/image-20210318093617001.png alt=image-20210318093617001></p><h2 id=jdk-nio-线程模型>JDK NIO 线程模型</h2><p>在JDK 1.5后，引入了NIO，其中<code>Selector</code>是<code>Java NIO</code>核心组件中的一个。提供了IO的<code>多路复用模型</code>。多路复用模型使得可以使用<strong>一个线程</strong>来管理成千上万的连接，避免了线程上下文切换带来的开销，使得性能得到极大的提升。</p><h2 id=总结>总结</h2><p>通过上面的分析，总结来说Netty是基于JDK NIO来实现其事件循环的，在Linux中是通过epoll。当Netty 的 NioEventLoop 读取到消息之后，一直都是由NioEventLoop 调用用户的 ChannelHandler，期间不进行线程切换。既所有I/O操作和事件处理都在EventLoop所在的线程上执行。</p><p>在上文提到的例子中，通过<code>Thread.sleep</code>的调用，阻塞Handler的执行线程，而由于Handler和EventLoop其实是同一个线程，这就造成了EventLoop的线程也阻塞了。</p><p>但是在Swoole中，其
<a href=https://wiki.swoole.com/wiki/page/992.html target=_blank>睡眠函数
</a>通过替换底层的sleep函数，并不会阻塞PHP进程。</p><blockquote><p>最新的<code>4.2.0</code>版本增加了对<code>sleep</code>函数的<code>Hook</code>，底层替换了<code>sleep</code>、<code>usleep</code>、<code>time_nanosleep</code>、<code>time_sleep_until</code>四个函数。</p><p>当调用这些睡眠函数时会自动切换为协程定时器调度。不会阻塞进程。</p></blockquote><h2 id=结论>结论</h2><p><strong>在EventLoop这样的Reactor模式下，一定不要使用阻塞的sleep方式。</strong></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>TechNotes</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-03-17</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/netty/>Netty</a></div><nav class=post-nav><a class=next href=/post/2020/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%87%E8%B4%AD%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%92/><span class="next-text nav-default">服务器采购及网络存储规划</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><script src=https://utteranc.es/client.js repo=cloudhuang/cloudhuang.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script><noscript>Please enable JavaScript to view the <a href=https://github.com/utterance>comments powered by utterances.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://technotes.guru/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动</span>
<span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>TechNotes</span></span></div><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?077988cdd83c4fada527c368cf2c84a9";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script></body></html>